/*
 ============================================================================
 Name        : Recursive.c
 Author      : Daniel MÃ¥rtensson
 Version     : 1.0
 Copyright   : MIT
 Description : System identification example
 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>

#include "CControl/Headers/Configurations.h"
#include "CControl/Headers/Functions.h"

int main() {

	/*
	 * In this example we have selected the following configuration inside Confiugration.h
	 * SELECTED_CONTROL_STRATEGY AUTOMATIC
	 * q 1000 // Initial diagonal values for P matrix for system identification. 1000 is a good number
	 * LAMBDA 1 // Forgetting factor for system identification. Lambda Should not be less than zero
	 * POLY_LENGTH 5 // Length of polynomials A(q), B(q) and C(q) in Recursive least squares
	 * HORIZON 50 // How long we want to look in the future
	 * ALPHA 0.1 // This will prevent dead-beat control and gives more smooth input values
	 * INTEGRATION TRUE // Enable integral action inside model - Recommended
	 * ITERATION_LIMIT 100 // This is for MPC
	 * ANTI_WINDUP ALWAYS_INTEGRATE // The integral function for MRAC
	 * LEARNING 0.0001 // For MRAC
	 */

	/*
	 * Assume that we reading u(k), and y(k) from an ADC. In this case, we have
	 * a vector of u's and y's, but in real time running, we will not have this vector.
	 */
	float input[100] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
			2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
			2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 }; // Input signal

	float output[100] = { 0.00000, 0.00477, 0.01786, 0.03761, 0.06264, 0.09174,
			0.12390, 0.15827, 0.19412, 0.23085, 0.26796, 0.30504, 0.34175,
			0.37782, 0.41304, 0.44723, 0.48027, 0.51207, 0.54255, 0.57168,
			0.59943, 0.62581, 0.65081, 0.67447, 0.69680, 0.71785, 0.73765,
			0.75625, 0.77369, 0.79004, 0.80533, 0.81963, 0.83297, 0.84541,
			0.85701, 0.86780, 0.87784, 0.88717, 0.89584, 0.90388, 0.91134,
			0.91825, 0.92465, 0.93058, 0.93606, 0.94113, 0.94582, 0.95015,
			0.95415, 0.95784, 0.96124, 0.96915, 0.98513, 1.00755, 1.03503,
			1.06640, 1.10064, 1.13692, 1.17453, 1.21288, 1.25148, 1.28993,
			1.32790, 1.36513, 1.40141, 1.43658, 1.47052, 1.50313, 1.53437,
			1.56419, 1.59258, 1.61953, 1.64507, 1.66921, 1.69199, 1.71345,
			1.73362, 1.75257, 1.77033, 1.78697, 1.80252, 1.81706, 1.83062,
			1.84327, 1.85505, 1.86601, 1.87621, 1.88568, 1.89447, 1.90263,
			1.91020, 1.91721, 1.92370, 1.92971, 1.93527, 1.94041, 1.94516,
			1.94955, 1.95360, 1.95734 };

	/*
	 * Estimation SISO model - Assume that this this is inside the microprocessor's while(1) loop
	 */
	float past_e; // The past e
	float past_y; // The past y
	float past_u; // The past u
	float phi[NP + NZ + NZE];
	float P[(NP + NZ + NZE) * (NP + NZ + NZE)];
	float theta[NP + NZ + NZE]; // Remember that total length is POLY_LENGTH*3 - ALWAYS have these dimensions
	int count = 0; // Initial set to 0. Will be counted to 2 then stop. Set count = 0 again and the algorithm starts over
	for (int i = 0; i < sizeof(output) / sizeof(output[0]); i++) {
		rls(theta, input[i], output[i], &count, &past_e, &past_y, &past_u, phi,
				P);
	}

	/*
	 * Find our state space model with kalman gain matrix from theta - ALWAYS have these dimensions
	 */
	float A[ADIM * ADIM];
	float B[ADIM * RDIM];
	float C[YDIM * ADIM];
	float K[ADIM * YDIM]; // (ADIM-1) only if we have INTEGRATION TRUE, else ADIM
	theta2ss(A, B, C, theta, K);

	/*
	 * Print our state space matrix
	 */
	printf("System matrix: A\n");
	print(A, ADIM, ADIM);

	printf("Input matrix: B\n");
	print(B, ADIM, RDIM);

	printf("Output matrix: C\n");
	print(C, YDIM, ADIM);

	printf("Kalman gain matrix: K\n");
	print(K, ADIM, YDIM);

	/*
	 * Create input u, output y and state vector x
	 */
	float u[RDIM] = { 2.2};
	float y[YDIM] = { 5.134};
	float x[ADIM] = { 2.32,
			          4.12,
					  1.34,
	                  2.11,
	                  5.21,
					  0 // <-- Last state does not matter in Kalman function due to integration
	};

	/*
	 * Call kalman function and estimate our future state at x(k+1)
	 */
	printf("Our current state vector is:\n");
	print(x, ADIM, 1);
	kalman(A, B, C, K, u, x, y);
	printf("Our estimated state vector is:\n");
	print(x, ADIM, 1);

	return EXIT_SUCCESS;
}
